use halo2_proofs::{
    circuit::{AssignedCell, Chip, Layouter, SimpleFloorPlanner, Value},
    pasta::{pallas, EqAffine, Fp},
    plonk::{create_proof, keygen_pk, keygen_vk, verify_proof, SingleVerifier},
    plonk::{Advice, Circuit, Column, ConstraintSystem, Error, Fixed, Instance, Selector},
    poly::{commitment::Params, Rotation},
    transcript::{Blake2bRead, Blake2bWrite, Challenge255},
};
use pasta_curves::vesta;
use rand::rngs::OsRng;

// We define three chips (one for add, one for sub and one for mul).

/// Define instructions that we would like to use with our chip AddSubMulChip
pub(crate) trait AddSubMulInstructions:
    AddInstructions + SubInstructions + MulInstructions
{
    /// Variable representing a number.
    type Num;

    /// Loads a private value into an advice column of the circuit.
    fn load_private(
        &self,
        layouter: impl Layouter<Fp>,
        a: Value<Fp>,
    ) -> Result<<Self as AddSubMulInstructions>::Num, Error>;

    /// Loads a constant value into an advice column of the circuit.
    fn load_constant(
        &self,
        layouter: impl Layouter<Fp>,
        constant: Fp,
    ) -> Result<<Self as AddSubMulInstructions>::Num, Error>;

    /// Check that a number is equal to a public input.
    fn check_result(
        &self,
        layouter: impl Layouter<Fp>,
        num: <Self as AddSubMulInstructions>::Num,
        row: usize,
    ) -> Result<(), Error>;
}

pub(crate) trait AddInstructions {
    type Num;

    /// Define and assign a region for an add gate
    /// - Copy the input values in the input cells
    /// - Evaluate the output value (a+b) and store it in the output cell
    fn add(
        &self,
        layouter: impl Layouter<Fp>,
        a: Self::Num,
        b: Self::Num,
    ) -> Result<Self::Num, Error>;
}

pub(crate) trait SubInstructions {
    type Num;

    /// Define and assign a region for an sub gate
    /// - Copy the input values in the input cells
    /// - Evaluate the output value (a-b) and store it in the output cell
    fn sub(
        &self,
        layouter: impl Layouter<Fp>,
        a: Self::Num,
        b: Self::Num,
    ) -> Result<Self::Num, Error>;
}

pub(crate) trait MulInstructions {
    type Num;

    /// Define and assign a region for an mul gate
    /// - Copy the input values in the input cells
    /// - Evaluate the output value (a*b) and store it in the output cell
    fn mul(
        &self,
        layouter: impl Layouter<Fp>,
        a: Self::Num,
        b: Self::Num,
    ) -> Result<Self::Num, Error>;
}

/// AddSubMulChip will implement our operations.
pub(crate) struct AddSubMulChip {
    config: AddSubMulConfig,
}

pub(crate) struct AddChip {
    config: AddConfig,
}

pub(crate) struct SubChip {
    config: SubConfig,
}

pub(crate) struct MulChip {
    config: MulConfig,
}

/// Chip state is stored in a config struct.
/// AddSubMulConfig is generated by the chip during configuration, and then stored inside the chip.
#[derive(Clone, Debug)]
pub(crate) struct AddSubMulConfig {
    /// For our chip, we will use
    /// - 2 advice columns
    /// - 1 public input column
    /// - 1 selector to enable the addition gate
    /// - 1 selector to enable the subtraction gate
    /// - 1 selector to enable the multiplication gate
    advice: [Column<Advice>; 2],
    instance: Column<Instance>,
    add_config: AddConfig,
    sub_config: SubConfig,
    mul_config: MulConfig,
}

#[derive(Clone, Debug)]
pub(crate) struct AddConfig {
    /// For our chip, we will use
    /// - 2 advice columns
    /// - 1 selector to enable the add gate
    advice: [Column<Advice>; 2],
    s_add: Selector,
}

#[derive(Clone, Debug)]
pub(crate) struct SubConfig {
    /// For our chip, we will use
    /// - 2 advice columns
    /// - 1 selector to enable the sub gate
    advice: [Column<Advice>; 2],
    s_sub: Selector,
}

#[derive(Clone, Debug)]
pub(crate) struct MulConfig {
    /// For our chip, we will use
    /// - 2 advice columns
    /// - 1 selector to enable the mul gate
    advice: [Column<Advice>; 2],
    s_mul: Selector,
}

impl Chip<Fp> for AddSubMulChip {
    type Config = AddSubMulConfig;
    type Loaded = ();

    fn config(&self) -> &Self::Config {
        &self.config
    }

    fn loaded(&self) -> &Self::Loaded {
        &()
    }
}

impl Chip<Fp> for AddChip {
    type Config = AddConfig;
    type Loaded = ();

    fn config(&self) -> &Self::Config {
        &self.config
    }

    fn loaded(&self) -> &Self::Loaded {
        &()
    }
}

impl Chip<Fp> for SubChip {
    type Config = SubConfig;
    type Loaded = ();

    fn config(&self) -> &Self::Config {
        &self.config
    }

    fn loaded(&self) -> &Self::Loaded {
        &()
    }
}

impl Chip<Fp> for MulChip {
    type Config = MulConfig;
    type Loaded = ();

    fn config(&self) -> &Self::Config {
        &self.config
    }

    fn loaded(&self) -> &Self::Loaded {
        &()
    }
}
impl AddChip {
    pub(crate) fn new(config: AddConfig) -> Self {
        Self { config }
    }

    pub(crate) fn configure(
        meta: &mut ConstraintSystem<Fp>,
        advice: [Column<Advice>; 2],
    ) -> AddConfig {
        let s_add = meta.selector();

        meta.create_gate("add", |meta| {
            let lhs = meta.query_advice(advice[0], Rotation::cur());
            let rhs = meta.query_advice(advice[1], Rotation::cur());
            let out = meta.query_advice(advice[0], Rotation::next());
            let s_add = meta.query_selector(s_add);
            vec![s_add * (lhs + rhs - out)]
        });

        AddConfig { advice, s_add }
    }
}

impl AddInstructions for AddSubMulChip {
    type Num = AssignedCell<Fp, Fp>;

    fn add(
        &self,
        layouter: impl Layouter<Fp>,
        a: Self::Num,
        b: Self::Num,
    ) -> Result<Self::Num, Error> {
        let add_chip = AddChip::new(self.config.add_config.clone());
        add_chip.add(layouter, a, b)
    }
}

impl AddInstructions for AddChip {
    type Num = AssignedCell<Fp, Fp>;

    fn add(
        &self,
        mut layouter: impl Layouter<Fp>,
        a: Self::Num,
        b: Self::Num,
    ) -> Result<Self::Num, Error> {
        layouter.assign_region(
            || "add",
            |mut region| {
                self.config.s_add.enable(&mut region, 0)?;

                a.copy_advice(|| "lhs", &mut region, self.config.advice[0], 0)?;
                b.copy_advice(|| "rhs", &mut region, self.config.advice[1], 0)?;

                let value = a.value().copied() + b.value();

                region.assign_advice(|| "lhs + rhs", self.config.advice[0], 1, || value)
            },
        )
    }
}

impl SubChip {
    pub(crate) fn new(config: SubConfig) -> Self {
        Self { config }
    }

    pub(crate) fn configure(
        meta: &mut ConstraintSystem<Fp>,
        advice: [Column<Advice>; 2],
    ) -> SubConfig {
        let s_sub = meta.selector();

        meta.create_gate("sub", |meta| {
            let lhs = meta.query_advice(advice[0], Rotation::cur());
            let rhs = meta.query_advice(advice[1], Rotation::cur());
            let out = meta.query_advice(advice[0], Rotation::next());
            let s_sub = meta.query_selector(s_sub);
            vec![s_sub * (lhs - rhs - out)]
        });

        SubConfig { advice, s_sub }
    }
}

impl SubInstructions for AddSubMulChip {
    type Num = AssignedCell<Fp, Fp>;

    fn sub(
        &self,
        layouter: impl Layouter<Fp>,
        a: Self::Num,
        b: Self::Num,
    ) -> Result<Self::Num, Error> {
        let sub_chip = SubChip::new(self.config.sub_config.clone());
        sub_chip.sub(layouter, a, b)
    }
}

impl SubInstructions for SubChip {
    type Num = AssignedCell<Fp, Fp>;

    fn sub(
        &self,
        mut layouter: impl Layouter<Fp>,
        a: Self::Num,
        b: Self::Num,
    ) -> Result<Self::Num, Error> {
        layouter.assign_region(
            || "sub",
            |mut region| {
                self.config.s_sub.enable(&mut region, 0)?;

                a.copy_advice(|| "lhs", &mut region, self.config.advice[0], 0)?;
                b.copy_advice(|| "rhs", &mut region, self.config.advice[1], 0)?;

                let value = a.value().copied() - b.value();

                region.assign_advice(|| "lhs - rhs", self.config.advice[0], 1, || value)
            },
        )
    }
}

//

impl MulChip {
    pub(crate) fn new(config: MulConfig) -> Self {
        Self { config }
    }

    pub(crate) fn configure(
        meta: &mut ConstraintSystem<Fp>,
        advice: [Column<Advice>; 2],
    ) -> MulConfig {
        let s_mul = meta.selector();

        meta.create_gate("mul", |meta| {
            let lhs = meta.query_advice(advice[0], Rotation::cur());
            let rhs = meta.query_advice(advice[1], Rotation::cur());
            let out = meta.query_advice(advice[0], Rotation::next());
            let s_mul = meta.query_selector(s_mul);
            vec![s_mul * (lhs * rhs - out)]
        });

        MulConfig { advice, s_mul }
    }
}

impl MulInstructions for AddSubMulChip {
    type Num = AssignedCell<Fp, Fp>;

    fn mul(
        &self,
        layouter: impl Layouter<Fp>,
        a: Self::Num,
        b: Self::Num,
    ) -> Result<Self::Num, Error> {
        let mul_chip = MulChip::new(self.config.mul_config.clone());
        mul_chip.mul(layouter, a, b)
    }
}

impl MulInstructions for MulChip {
    type Num = AssignedCell<Fp, Fp>;

    fn mul(
        &self,
        mut layouter: impl Layouter<Fp>,
        a: Self::Num,
        b: Self::Num,
    ) -> Result<Self::Num, Error> {
        layouter.assign_region(
            || "mul",
            |mut region| {
                self.config.s_mul.enable(&mut region, 0)?;

                a.copy_advice(|| "lhs", &mut region, self.config.advice[0], 0)?;
                b.copy_advice(|| "rhs", &mut region, self.config.advice[1], 0)?;

                let value = a.value().copied() * b.value();

                region.assign_advice(|| "lhs * rhs", self.config.advice[0], 1, || value)
            },
        )
    }
}

impl AddSubMulChip {
    pub(crate) fn new(config: AddSubMulConfig) -> Self {
        Self { config }
    }

    pub(crate) fn configure(
        meta: &mut ConstraintSystem<Fp>,
        advice: [Column<Advice>; 2],
        instance: Column<Instance>,
        constant: Column<Fixed>,
    ) -> AddSubMulConfig {
        let add_config = AddChip::configure(meta, advice);
        let sub_config = SubChip::configure(meta, advice);
        let mul_config = MulChip::configure(meta, advice);

        meta.enable_equality(instance);
        meta.enable_constant(constant);
        for column in &advice {
            meta.enable_equality(*column);
        }

        AddSubMulConfig {
            advice,
            instance,
            add_config,
            sub_config,
            mul_config,
        }
    }
}

impl AddSubMulInstructions for AddSubMulChip {
    type Num = AssignedCell<Fp, Fp>;

    /// Loads a private value into an advice column of the circuit.
    fn load_private(
        &self,
        mut layouter: impl Layouter<Fp>,
        value: Value<Fp>,
    ) -> Result<<Self as AddSubMulInstructions>::Num, Error> {
        layouter.assign_region(
            || "load private",
            |mut region| {
                region.assign_advice(|| "private input", self.config.advice[0], 0, || value)
            },
        )
    }

    /// Loads a constant value into an advice column of the circuit.
    fn load_constant(
        &self,
        mut layouter: impl Layouter<Fp>,
        constant: Fp,
    ) -> Result<<Self as AddSubMulInstructions>::Num, Error> {
        layouter.assign_region(
            || "load constant",
            |mut region| {
                region.assign_advice_from_constant(
                    || "constant value",
                    self.config.advice[0],
                    0,
                    constant,
                )
            },
        )
    }

    /// Check that a number is equal to a public input.
    fn check_result(
        &self,
        mut layouter: impl Layouter<Fp>,
        num: <Self as AddSubMulInstructions>::Num,
        row: usize,
    ) -> Result<(), Error> {
        layouter.constrain_instance(num.cell(), self.config.instance, row)
    }
}

/// The full circuit implementation.
/// In this struct we store the private input variables. We use `Option<Fp>` because
/// they won't have any value during key generation. During proving, if any of these
/// were `None` we would get an error.

#[derive(Default, Clone)]
struct MyCircuit {
    a: Value<pallas::Base>,
    b: Value<pallas::Base>,
    c: Value<pallas::Base>,
}

impl Circuit<Fp> for MyCircuit {
    // Since we are using a single chip for everything, we can just reuse its config.
    type Config = AddSubMulConfig;
    type FloorPlanner = SimpleFloorPlanner;

    fn without_witnesses(&self) -> Self {
        Self::default()
    }

    fn configure(meta: &mut ConstraintSystem<Fp>) -> Self::Config {
        // We create the columns that our chip needs
        // - 2 advice columns to store private inputs and intermediate values
        // - one instance column to store public inputs
        // - one fixed column to store constants
        let advice = [meta.advice_column(), meta.advice_column()];
        let instance = meta.instance_column();
        let constant = meta.fixed_column();

        AddSubMulChip::configure(meta, advice, instance, constant)
    }

    fn synthesize(
        &self,
        config: Self::Config,
        mut layouter: impl Layouter<Fp>,
    ) -> Result<(), Error> {
        let chip = AddSubMulChip::new(config);

        // Load our private values into the circuit.
        let a = chip.load_private(layouter.namespace(|| "load a"), self.a)?;
        let b = chip.load_private(layouter.namespace(|| "load b"), self.b)?;
        let c = chip.load_private(layouter.namespace(|| "load c"), self.c)?;

        let a2 = chip.mul(layouter.namespace(|| "a * a"), a.clone(), a.clone())?;

        let a2_add_b = chip.add(layouter.namespace(|| "a * a + b"), a2.clone(), b.clone())?;

        let expect = chip.sub(layouter.namespace(|| "a * a + b - c"), a2_add_b, c)?;

        // Check that expect = a * a + b - c is equal to our public input.
        chip.check_result(layouter.namespace(|| "check res"), expect, 0)
    }
}

#[test]
pub fn run_add_sub_example() {
    // The number of rows in our circuit cannot exceed 2^k. Since our example
    // circuit is very small, we can pick a very small value here.
    let number_rows = 5;

    // Prepare the private and constant inputs
    let a = pallas::Base::from(2u64);
    let b = pallas::Base::from(3u64);
    let c = pallas::Base::from(5u64);

    // Instantiate the circuit with these private/constant inputs.
    let circuit = MyCircuit {
        a: Value::known(a),
        b: Value::known(b),
        c: Value::known(c),
    };

    // Initialize the polynomial commitment parameters
    let params: Params<EqAffine> = Params::new(number_rows);
    let vk = keygen_vk(&params, &circuit).unwrap();
    let pk = keygen_pk(&params, vk, &circuit).unwrap();
    let public_input = vesta::Scalar::from(2);

    let mut transcript = Blake2bWrite::<_, _, Challenge255<_>>::init(vec![]);
    create_proof(
        &params,
        &pk,
        &[circuit.clone()],
        &[&[&[public_input]]],
        OsRng,
        &mut transcript,
    )
    .unwrap();
    let proof = transcript.finalize();
    println!("Proof length: {:?}", proof.len());

    let strategy = SingleVerifier::new(&params);
    let mut transcript = Blake2bRead::<_, _, Challenge255<_>>::init(&proof[..]);
    match verify_proof(
        &params,
        pk.get_vk(),
        strategy,
        &[&[&[public_input]]],
        &mut transcript,
    ) {
        Ok(()) => println!("The statement is TRUE"),
        Err(error) => {
            println!("The statement is FALSE.");
            println!("ERROR: {}", error);
        }
    };
}
